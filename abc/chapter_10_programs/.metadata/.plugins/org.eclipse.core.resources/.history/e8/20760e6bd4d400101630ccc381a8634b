/* Functions for Doubly-Linked Lists. */

#include "dllist.h"

/* Prints a list of DATA values by following the links. */
void print_list(NODE *list)
{
	print_node_data(list -> prev);
	while(list != NULL) {
		print_node_data(list);
		list = list -> next;
	}
	print_node_data(list);
	putchar('\n');
}

/* Prints a list of DATA values by following the links. */
void print_list_reverse(NODE *list)
{
	while(list -> next != NULL) {
		list = list -> next;
	}
	print_node_data(list -> next);
	while (list != NULL) {
		print_node_data(list);
		list = list -> prev;
	}
	print_node_data(list);
	putchar('\n');
}

/* Prints the data stored in the given node. */
void print_node_data(NODE *n)
{
	if (n == NULL) {
		printf("list NODE:  NULL\n");
	}
	else if (n != NULL) {
		printf("list NODE:  %s%10s%s%d%s%d\n",
								"name: ", n -> data.name,
								", age: ", n -> data.age,
								", weight: ", n -> data.weight);
	}
	else {
		printf("--MISSING NULL!--\n");
	}
}

/* Creates a DATA list from an array of DATA values
 * and returns a reference to the head of the list. */
NODE* create_l(DATA *array, int n)
{
	int i;
	NODE *p, *list;
	p = malloc(sizeof(NODE));
	list = p;

	p -> prev = NULL;
	for (i = 0; i < n - 1; ++i) {
		NODE *tmp = p;
		p -> data = *(array + i);
		p -> next = malloc(sizeof(NODE));
		p = p -> next;
		p -> prev = tmp;
	}
	p -> data = *(array + n - 1);
	p -> next = NULL;

	return list;
}

/* Inserts an element into the given list, at the
 * given list position (starting from 1). */
void insert(DATA d, NODE *list, int pos)
{
	NODE *p, *prev, *next;
	assert(pos >= 0);
	assert(list != NULL);

	p = malloc(sizeof(NODE));
	p -> data = d;
	if (pos == 0) {
		prev = get_node(list, pos) -> prev;
		next = list;
		list = p;
	}
	else {
		int length = cnt_list(list);
		if (pos > (length - 1)) {
			pos = length;
		}
		prev = get_node(list, pos - 1);
		next = prev -> next;
		prev -> next = p;
	}
	p -> next = next;
	p -> prev = prev;
	if (next != NULL) {
		next -> prev = p;
	}
}

/* Deletes an element at the given list position
 * in the given list (starting from 1).
 */
void delete(NODE *list, int pos)
{
	NODE *p, *prev, *next;
	assert(pos >= 0);
	assert(list != NULL);

	p = get_node(list, pos);
	assert(p != NULL);
	prev = p -> prev;
	next = p -> next;
	if (pos == 0) {
		list = next;
	}
	else {
		prev -> next = next;
	}
	if (next != NULL) {
		next -> prev = prev;
	}
	free(p);
}

/* Returns a pointer to the NODE at the given list
 * position in the given list. */
NODE* get_node(NODE* list, int pos)
{
	int i = 0;
	assert(pos >= 0);
	assert(list != NULL);

	while (i < (pos - 1)) {
		if (list == NULL) {
			return list;
		}
		list = list -> next;
		++i;
	}
	return list;
}

//Counts the length of a list.
int cnt_list(NODE *list)
{
	if (list == NULL) {
		return 0;
	}
	else {
		return cnt_list(list -> next) + 1;
	}
}

/* Checks to see whether a list is a cycle. */
boolean iscycle(NODE *list)
{
	int head_ad = (int) list;
	while (list -> next != NULL) {
		list = list -> next;
		if (((int) list) == head_ad) {
			return true;
		}
	}
	return false;
}
