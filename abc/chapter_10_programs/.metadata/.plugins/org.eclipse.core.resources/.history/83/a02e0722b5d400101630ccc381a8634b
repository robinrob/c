/* Functions for Singly-Linked Lists. */

#include "sllist.h"

/* Creates a DATA list from an array of DATA values
 * and returns a reference to the head of the list. */
NODE* create_l(DATA *array, int n)
{
	int i;
	NODE *p, *list;
	p = malloc(sizeof(NODE));
	list = p;

	for (i = 0; i < n - 1; ++i) {
		p -> data = *(array + i);
		p -> next = malloc(sizeof(NODE));
		p = p -> next;
	}
	p -> data = *(array + n - 1);
	p -> next = NULL;

	return list;
}

/* Prints a list of DATA values by following the links. */
void print_list(NODE *list)
{
	while(list != NULL) {
		printf("list NODE:  %s%10s%s%d%s%d\n",
						"name: ", list -> data.name,
						", age: ", list -> data.age,
						", weight: ", list -> data.weight);
		list = list -> next;
	}
	if (list == NULL) {
		printf("list NODE:  NULL\n");
	}
	else {
		printf("--MISSING NULL!--\n");
	}
	putchar('\n');
}

/* Prints a list of DATA values using iteration. */
void print_list_it(NODE *list)
{
	int i, n = cnt_list(list);

	printf("n: %d\n", n);
	for (i = 0; i < n; ++i) {
		printf("list element:  %s%10s%s%d%s%d\n",
						"name: ", list -> data.name,
						", age: ", list -> data.age,
						", weight: ", list -> data.weight);
		list = list -> next;
	}
	putchar('\n');
}

//Counts the length of a list.
int cnt_list(NODE *list)
{
	if (list == NULL) {
		return 0;
	}
	else {
		return cnt_list(list -> next) + 1;
	}
}



/* Checks to see if the two lists are equal. */
boolean check_equal_lists(NODE* list1, NODE *list2)
{
	while (list1 != NULL && list2 != NULL) {
		printf("looping\n");
		if (check_equal_data(list1 -> data, list2 -> data)) {
			return false;
		}
		list1 = list1 -> next;
		list2 = list2 -> next;
	}
	return true;
}

/* Checks to see if two DATA structures are equal or not. */
boolean check_equal_data(DATA d1, DATA d2)
{
	if (d1.name == d2.name &&
		d1.age == d2.age &&
		d1.weight == d2.weight) {
		return true;
	}
	return false;
}

/* Checks to see whether a list is a cycle. */
boolean iscycle(NODE *list)
{
	int head_ad = (int) list;
	while (list -> next != NULL) {
		list = list -> next;
		if (((int) list) == head_ad) {
			return true;
		}
	}
	return false;
}

/* Turns a cycling list into a straight & finite list. */
void decycle(NODE *list)
{
	int head_ad = (int) list;
	while (list -> next != NULL) {
		if ((int) (list -> next) == head_ad) {
			list -> next = NULL;
			break;
		}
		list = list -> next;
	}
}





