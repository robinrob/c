/* Quicksort! Pointer version with macros. */

#include "sort.h"

#define swap(x, y)		{ int t; t = x; x = y; y = t; }
#define order(x, y)		if (x > y) swap(x, y)
#define o2(x, y)		order(x, y)
#define o3(x, y, z)		o2(x, y); o2(x, z); o2(y, z)

typedef enum {yes, no} yes_no;

static yes_no find_pivot(char **left, char **right, int *pivot_ptr);
static char **partition(char **left, char **right, int pivot);

void quicksort(char **list, int n, char **left, char **right)
{
  char **p;
  int pivot;

  printf("quicksort: *left: %s, *right: %s\n", *left, *right);
  printf("quicksort: sublist: \n");
  print_listvals(left, right);

  if (find_pivot(left, right, &pivot) == yes) {
    p = partition(left, right, pivot);
    quicksort(list, n, left, p - 1);
    quicksort(list, n, p, right);
  }
}

static yes_no find_pivot(char **left, char **right, int *pivot_ptr)
{
  int a, b, c, val_l, val_r, val_p;
  char **p;

  val_l = str_val(*left);
  val_r = str_val(*right);

  a = val_l;
  b = str_val(*(left + (right - left) / 2));
  c = val_r;
  o3(a, b, c);
  if (a < b) {
    *pivot_ptr = b;
    return yes;
  }
  if (b < c) {
    *pivot_ptr = c;
    return yes;
  }
  for (p = left + 1; p <= right; ++p) {
    val_p = str_val(*p);
    if (val_p != val_l) {
      *pivot_ptr = val_p < val_l ? val_l : val_p;
      return yes;
    }
  }
  return no;
}

char **partition(char **left, char **right, int pivot)
{
  while (left <= right) {
    while (str_val(*left) < pivot))
      ++left;
    while (str_val(*right) >= pivot)
      --right;
    if (left < right) {
      swap_string(left, right);
      ++left;
      --right;
    }
  }
  return left;
}

